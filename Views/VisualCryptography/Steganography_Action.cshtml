@using CryptoWebService.Helpers;

<div class="row row-eq-height">
    <div class="col-lg-4">
        <div class="layer">
            <label>Metoda kodowania</label>
            <select id="MethodSelect" class="form-control" onchange="OnChangeMethodSelect(this.value)">
                <option value="1">algorytm najmniej znaczącego bitu</option>
                <option value="2" selected>patchwork</option>
            </select>
        </div>
        <div class="layer" id="Method1">
            <label style="margin-bottom:10px;">
                Ilość bitów przeznaczona na kodowanie
            </label>
            <div class="slidecontainer">
                <div class="col-lg-10">
                    <input type="range" min="1" max="8" value="1" style="margin-top:5px;" class="slider" id="AmountOfBitsSlider">
                </div>
                <div class="col-lg-2">
                    <span id="AmountOfBitsValue" style="font-size:18px;"> </span>
                </div>
            </div>
        </div>
        <div class="layer" id="Method2">
            <label style="margin-bottom:10px;">
                Metoda 2
            </label>
        </div>
    </div>
    <div class="col-lg-8" style="display: flex;flex-direction: column;">
        <label for="inputEncrypt">Opis metody</label>
        <label class="form-control" style="height: 100%" id="MethodDescription"></label>
    </div>
</div>


<div class="col-lg-12">
    <hr />
</div>

<div class="row">
    <div class="col-lg-12">
        <div class="col-lg-4">
            <label class="ImageHeader">Obraz w którym będą ukrywane dane</label>
        </div>
        <div class="col-lg-8">
            <label for="inputModeSelect">Wybierz źródło obrazu:</label>
            <select id="inputModeSelect" class="form-control" style="margin-bottom: 20px">
                <option value="file" selected>Plik</option>
                <option value="drawing">Rysunek</option>
            </select>
        </div>
    </div>
    <div class="col-lg-12">
        <div id="FileUploadPanel">
            <div class="col-lg-12">
                @{
                    await Html.RenderPartialAsync(ViewControlsHelper.GetControlPath("UploadControl"), "Image");
                }
            </div>
        </div>
        <div id="drawingPanel" style="display: none">
            <div id="DrawingContainer" class="myCanvas">

            </div>
            <div class="text-center mySignature">Pole do rysowania</div>
        </div>
    </div>
</div>

<div id="PanelAfterUploadImage" style="display:none">
    <div class="col-lg-12">
        <hr />
    </div>
    <div class="row">
        <div class="col-lg-12">
            <div class="col-lg-4">
                <label class="ImageHeader">Dane ukrywane w obrazie</label><label class="ImageDescription"> &nbsp- wybierz źródło obrazu:</label>
            </div>
            <div class="col-lg-8">
                <select id="inputModeSelectData" class="form-control" style="margin-bottom: 20px">
                    <option value="file" selected>Plik</option>
                    <option value="text">Tekst</option>
                </select>
            </div>
        </div>
        <div class="col-lg-12">
            <div id="FileUploadPanelData">
                <div class="col-lg-12">
                    @{
                        await Html.RenderPartialAsync(ViewControlsHelper.GetControlPath("UploadControl"), "Data");
                    }
                </div>
            </div>
        </div>
    </div>
    <div class="text-center" style="margin-top: 20px">
        <button class="btn btn-primary" id="sendCanvasToDivide">Podziel na sekrety !</button>

        <div id="loading" class="loader" style="display:none"></div>
    </div>
</div>


<div class="row" id="PanelWithResult" style="display:none">
    <div class="col-lg-12">
        <hr />
    </div>
    <div id="secretsDownload" class="text-center">

    </div>
    <div class="col-lg-12">
        <div id="Secret">
            <div id="DisplayContainer" class="myCanvas">

            </div>
            <div class="text-center mySignature">Podgląd sekretów</div>
        </div>
    </div>
</div>

<style>
    .layer {
        margin-top: 5px;
        margin-bottom: 10px;
    }

    .ImageHeader {
        color: #1c5aa6;
    }

    .ImageDescription {
        font-size: 16px;
    }

    .row-eq-height {
        display: -webkit-box;
        display: -webkit-flex;
        display: -ms-flexbox;
        display: flex;
    }

    .myCanvas {
        background-color: #F0F0F0;
        border: 1px solid black;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }

    .mySignature {
        font-style: italic;
        margin-top: 10px;
        margin-bottom: 10px;
    }

    .myDownload {
        margin: 10px;
        font-size: 30px;
        margin-top: 10px;
        margin-bottom: 20px;
    }
</style>

<script>
    var isPaint = false;
    var lastPointerPosition;
    var DisplayLayer = new Konva.Layer();

    var MethodsDescriptions = [];
    MethodsDescriptions["1"] = ["Jedną z najprostrzych metod osadzania znaku wodnego jest moetoda polegajaca na zmianie najmniej znaczącego bitu słowa oposującego dany piksel.Jej wynik zależy ściśle od liczby bitów przeznaczonych do zapisu pojedynczego piksela:im więcej bitów opisuje dany, piksel, tym mniejsze znaczenie ma dla globalnegoodczucia odbiorcy modyfikacja jednego lub kilku ostatnich bitów.Oznaczony wtaki sposób obraz można łątwo sfałszować, dokonując zamiany formatu, np.bmpna gif, zmniejszajac głębie koloru itp.bądź poddając go kompresji w trakciezmiany formatu na jpg.Zawarta w orbrazie informacja zostaje uszkodzona."];
    MethodsDescriptions["2"] = ["opis paptchwork"];


    var slider = document.getElementById("AmountOfBitsSlider");
    var output = document.getElementById("AmountOfBitsValue");
    output.innerHTML = slider.value;

    slider.oninput = function () {
        output.innerHTML = this.value;
    }

    $(document).ready(function () {
        $("#MethodSelect").val("1").change();
        $('[data-toggle="tooltip"]').tooltip();
        InitDrawingKonvoControl('DrawingContainer', 300);
        InitDisplayKonvoControl('DisplayContainer', 600);
    });

    $('#inputModeSelect').on('change', function () {
        if (this.value === 'drawing') {
            $('#FileUploadPanel').hide();
            $('#drawingPanel').show();
            $('#PanelAfterUploadImage').show();
        } else if (this.value === 'file') {
            $('#FileUploadPanel').show();
            $('#drawingPanel').hide();
            $('#PanelAfterUploadImage').hide();
        }
        else {
            Console.log("InputModeSelect value is unknow.")
        }
    });

    function OnChangeMethodSelect(methodNumber){
        var label = document.getElementById("MethodDescription");

        if (methodNumber == 1) {
            $('#Method1').show();
            $('#Method2').hide();
        } else if (methodNumber == 2) {
            $('#Method1').hide();
            $('#Method2').show();
        } else {
            $('#Method1').hide();
            $('#Method2').hide();
            Console.log("InputMethodSelect value is unknow.")
            label.innerHTML = "";
            return;
        }
        label.innerHTML = MethodsDescriptions[methodNumber];
    }

    function GetWidth() {
        var width = document.getElementById('Description').offsetWidth;
        if (width === 0) {
            width = document.getElementById('Tools').offsetWidth;
            if (width === 0) {
                width = 400;
            }
        }
        return width - 28;
    }

    function InitDisplayKonvoControl(stageName, stageHeight)
    {
        var stage = new Konva.Stage({
            container: stageName,
            width: GetWidth(),
            height: stageHeight
        });

        stage.add(DisplayLayer);

        DisplayLayer.on('mouseover', function (evt) {
            var shape = evt.target;
            document.body.style.cursor = 'pointer';
            DisplayLayer.draw();
        });

        DisplayLayer.on('mouseout', function (evt) {
            var shape = evt.target;
            document.body.style.cursor = 'default';
            shape.scaleX(1);
            shape.scaleY(1);
            DisplayLayer.draw();
        });

        var scrollLayers = new Konva.Layer();
        stage.add(scrollLayers);

        const PADDING = 5;

        var verticalBar = new Konva.Rect({
            width: 10,
            height: 100,
            fill: 'grey',
            opacity: 0.8,
            x: stage.width() - PADDING - 10,
            y: PADDING,
            draggable: true,
            dragBoundFunc: function (pos) {
                pos.x = stage.width() - PADDING - 10;
                pos.y = Math.max(Math.min(pos.y, stage.height() - this.height() - PADDING), PADDING);
                return pos;
            }
        });
        scrollLayers.add(verticalBar);
        scrollLayers.draw();

        verticalBar.on('dragmove', function () {
            const availableHeight = stage.height() - PADDING * 2 - verticalBar.height();
            var delta = (verticalBar.y() - PADDING) / availableHeight;

            DisplayLayer.y(-stage.height() * delta);
            DisplayLayer.batchDraw();
        });

        var horizontalBar = new Konva.Rect({
            width: 100,
            height: 10,
            fill: 'grey',
            opacity: 0.8,
            x: PADDING,
            y: stage.height() - PADDING - 10,
            draggable: true,
            dragBoundFunc: function (pos) {
                pos.x = Math.max(Math.min(pos.x, stage.width() - this.width() - PADDING), PADDING);
                pos.y = stage.height() - PADDING - 10;

                return pos;
            }
        });
        scrollLayers.add(horizontalBar);
        scrollLayers.draw();

        horizontalBar.on('dragmove', function () {
            const availableWidth = stage.width() - PADDING * 2 - horizontalBar.width();
            var delta = (horizontalBar.x() - PADDING) / availableWidth;

            DisplayLayer.x(-stage.width() * delta);
            DisplayLayer.batchDraw();
        });
    }

    function InitDrawingKonvoControl(stageName, stageHeight)
    {
        var stage = new Konva.Stage({
            container: stageName,
            width: GetWidth(),
            height: stageHeight,
        });

        var layer = new Konva.Layer();
        stage.add(layer);

        var canvas = document.createElement('canvas');
        canvas.width = stage.width();
        canvas.height = stage.height();

        var image = new Konva.Image({
            image: canvas
        });

        layer.add(image);
        stage.draw();

        var context = canvas.getContext('2d');
        context.strokeStyle = "black";
        context.lineWidth = 5;

        image.on('mousedown touchstart', function () {
            isPaint = true;
            lastPointerPosition = stage.getPointerPosition();
        });

        stage.addEventListener('mouseup touchend', function () {
            isPaint = false;
        });

        stage.addEventListener('mousemove touchmove', function () {
            if (!isPaint) {
                return;
            }
            context.globalCompositeOperation = 'source-over';
            context.strokeStyle = "black";
            context.beginPath();

            var localPos = {
                x: lastPointerPosition.x - image.x(),
                y: lastPointerPosition.y - image.y()
            };
            context.moveTo(localPos.x, localPos.y);
            var pos = stage.getPointerPosition();
            localPos = {
                x: pos.x - image.x(),
                y: pos.y - image.y()
            };
            context.lineTo(localPos.x, localPos.y);
            context.closePath();
            context.stroke();

            lastPointerPosition = pos;
            layer.batchDraw();
        });
    }

    function LoadImageToLayerFromData(layer, data) {
        var KonvoImage = new Konva.Image({
            draggable: true,
        });
        layer.add(KonvoImage);

        var image = new Image();
        image.onload = function () {
            KonvoImage.image(image);
            layer.draw();
        };

        image.src = 'data:image/png;base64,' + data;
    }

    $('#sendCanvasToDivide').click(function () {
        var inputModeEncrypt = $('#inputModeSelect option:selected').val();

        if (inputModeEncrypt === 'drawing') {
            var canvas = document.querySelector('#DrawingContainer canvas');
            sendDataToServer(canvas.toDataURL("image/png"));
        }
        else if (inputModeEncrypt === 'file') {
            var file = document.getElementById('ImageUploader').files[0];

            var reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = function () {
                sendDataToServer(reader.result.split(',')[1]);
            };
        }
    });

    function showLoading() {
        $('#loading').show();
    }

    function hideLoading() {
        $('#loading').hide();
    }

    function onSucces(response) {
        if (response.result === true) {
            var downloadLink = "";
            DisplayLayer.destroyChildren()
            for (var i = 0; i < response.secrets.length; i++) {
                var secret = response.secrets[i];
                LoadImageToLayerFromData(DisplayLayer, secret.value);
                downloadLink = downloadLink + '<div class="glyphicon glyphicon-download-alt" style="font-   ize:30px;"></div><a class="myDownload " href="data:application/octet-stream;charset=utf-16le;base64,' + secret.value + '" download="' + Date.now() + '_sekret_' + (i + 1)+'.png">Sekret ' + (i+1) +'</a>';
            }
            $('#secretsDownload').html(downloadLink);
        } else {
            alert(response.message);
            console.log(response);
        }
    }

    function sendDataToServer(imageData) {
        imageData = imageData.replace('data:image/png;base64,', '');

        $.ajax({
            type: 'POST',
            url: '@Url.Action("Steganography", "VisualCryptography")',
            data: JSON.stringify(imageData),
            dataType: 'json',
            contentType: "application/json",
            beforeSend: function () {
                showLoading();
            },
            complete: function () {
                hideLoading();
            },
            success: function (response) {
                onSucces(response);
            },
            error: function (response) {
                console.log(response);
            }
        });
    }
</script>
